package es.ucm.fdi.sscheck.gen

import org.scalacheck.Gen
import org.scalacheck.Arbitrary
import org.scalacheck.Arbitrary.arbitrary
import scala.language.implicitConversions
import es.ucm.fdi.sscheck.prop.tl.Timeout

/** Implicit conversions removed from BatchGen companion. This is needed
 *  because we cannot populate the name space with standard names for HO generators
 *  like of() or ofN(), but we also want to have these implicit conversions available
 */
object PStreamGenConversions {
  implicit def genDStream2DStreamGen[A](dsg : Gen[PStream[A]]) : PStreamGen[A] = PStreamGen(dsg)

  implicit def dstreamGen2batchSeqGen[A](gs : Gen[PStream[A]]) : Gen[Seq[Window[A]]] = gs.map(_.toSeq)
  implicit def batchSeqGen2dstreamGen[A](gs : Gen[Seq[Window[A]]]) : Gen[PStream[A]] = gs.map(PStream(_:_*))
}

/**
 * All the temporal generators defined in this object are sized generators, but the size parameters
 * only affects the number of batches in the output PDStream, not the size of the batches.
 * The size of the batches can be changed by using Gen.resize in the definition of the batch
 * generator that is passed to these HO generators
 *
 * On the other hand for generators of arbitrary PDStreams like Gen.resize(5, arbitrary[DStream[Int]])
 * Gen.resize has effect, both in the number of batches and in the size of the batches, as those
 * arbitrary instances are based on arbitrary for lists
 *
 *  TODO  That should be tested
  // by using Gen.resize(5, TLGen.always(Batch(List(0, 1)))) (constant batch size)
  // and then in Gen.resize(3, TLGen.always(BatchGen.ofNtoM(1, 5, Gen.choose(0, 3))))
  // the point is that we always have 3 batches, but Gen.resize doesn't affect the batch
  // size but only the number of batches
  //
 *
 * */
object PStreamGen {
  import PStreamGenConversions._

  def apply[A](dsg : Gen[PStream[A]]) : PStreamGen[A] = new PStreamGen(dsg)

  /** Arbitrary generator for DStream. Only works if an Arbitrary for Batch is also present.
   *  Note this hasn't been automatically derived from Buildables.buildableDStreamFromBatch
   *  for the same reason Gen.buildableOf has to be used with DStream instead of Gen.containerOf
   * */
  implicit def arbDStream[A](implicit arbBatch : Arbitrary[Window[A]]) : Arbitrary[PStream[A]] =
    Arbitrary(PStreamGen.of(arbitrary[Window[A]]))

   /*  This makes no sense for temporal generators, see third comment
    *  at issue #10
   */
//  /** Shrink function for DStream
//   * */
//  implicit def shrinkDStream[A] : Shrink[PDStream[A]] = Shrink(pdstream =>
//    // unwrap the underlying Seq, shrink the Seq, and rewrap
//    shrink(pdstream.toSeq).map(PDStream(_:_*))
//  )

  /** @return a generator of DStream that generates its batches from bg
   * */
  def of[T](bg : => Gen[Window[T]]) : Gen[PStream[T]] = {
    import Buildables.buildablePDStreamFromBatch
    Gen.buildableOf[PStream[T], Window[T]](bg)
  }
  /** @return a generator of DStream that generates its batches from bg
   * */
  def ofN[T](n : Int, bg : Gen[Window[T]]) : Gen[PStream[T]] = {
    import Buildables.buildablePDStreamFromBatch
    Gen.buildableOfN[PStream[T], Window[T]](n, bg)
  }
  /** @return a generator of DStream that generates its batches from bg
   * */
  def ofNtoM[T](n : Int, m : Int, bg : Gen[Window[T]]) : Gen[PStream[T]] = {
    import Buildables.buildablePDStreamFromBatch
    UtilsGen.buildableOfNtoM[PStream[T], Window[T]](n, m, bg)
  }

  /** @return a generator for the batch-by-batch concatenation of the PDStreams
  *  generated by gs1 and gs2. Note we fill either PDStreams with empty batches
  *  This implies PDStreams are implicitly treated as they where infinitely extended
  *  with empty batches
  */
  def dstreamUnion[A](gs1 : Gen[PStream[A]], gs2 : Gen[PStream[A]]) : Gen[PStream[A]] = {
    for {
      xs1 <- gs1
      xs2 <- gs2
    } yield xs1 #+ xs2
  }

  /** @return a dstream generator that has an empty batch followed by the batches
   *  from dsg
   * */
  def next[A](dsg : Gen[PStream[A]]) : Gen[PStream[A]] = {
    laterN(1, dsg)
  }

  /** @return a dstream generator that has n empty batches followed by the batches
   *  from dsg
   * */
  def laterN[A](n : Int, dsg : Gen[PStream[A]]) : Gen[PStream[A]] =
    for {
      ds <- dsg
      blanks = Seq.fill(n)(Window.empty : Window[A])
    } yield blanks ++ ds

  /**
   * This is sized generator where the size acts like the timeout, so
   * - with size <= 0 returns the empty PDStream, as no word can
   * succeed with a timeout of 0
   * - with size 1 returns a PDStream generated by dsg2
   * - otherwise dsg2 happens after between 0 and size-1 instants
   * */
  def until[A](dsg1 : Gen[PStream[A]], dsg2 : Gen[PStream[A]]) : Gen[PStream[A]] =
    Gen.sized { size =>
      if (size <= 0)
        Gen.const(PStream.empty)
      else if (size == 1)
        dsg2
      else
        for {
          proofOffset <- Gen.choose(0, size-1)
          prefix <- always(dsg1, Timeout(proofOffset))
          dsg2Proof <- laterN(proofOffset, dsg2)
        } yield prefix #+ dsg2Proof
    }

  def until[A](dsg1 : Gen[PStream[A]], dsg2 : Gen[PStream[A]], t : Timeout) : Gen[PStream[A]] =
    Gen.resize(t.instants, until(dsg1, dsg2))

  /** Sized generator where  the size acts like the timeout, so
   *  - with size <= 0 returns the empty PDStream
   *  - otherwise dsg happens at some moment between 0 and size instants
   */
  def eventually[A](dsg : Gen[PStream[A]]) : Gen[PStream[A]] =
    Gen.sized { size =>
      if (size <0)
        Gen.const(PStream.empty)
      else
        PStreamGen.ofNtoM(0, size -1, Window.empty : Window[A]) ++ dsg
    }
  def eventually[A](dsg : Gen[PStream[A]], t : Timeout) : Gen[PStream[A]] =
    Gen.resize(t.instants, eventually(dsg))

  /** Sized generator where the size acts like the timeout, so
   *  - with size <= 0 returns the empty PDStream
   *  - otherwise dsg happens size times from now
   */
  def always[A](dsg : Gen[PStream[A]]) : Gen[PStream[A]] =
    Gen.sized { size =>
      if (size <= 0) // supporting size == 0 is needed by the calls to always from until and release
        Gen.const(PStream.empty)
      else
        (for {
          offset <- 0 until size
        } yield laterN(offset, dsg)
        )
        .reduce(dstreamUnion(_,_))
    }
  def always[A](dsg : Gen[PStream[A]], t : Timeout) : Gen[PStream[A]] =
    Gen.resize(t.instants, always(dsg))

  /**
   *  Generator for the weak version of LTL release operator: either dsg2
   *  happens forever, or it happens until dsg1 happens, including the
   *  moment when dsg1 happens
   *
   *  This is a sized generator where the size acts like the timeout, so
   *   - with size <= 0 returns the empty PDStream
   *   - otherwise, if dsg1 happens then it happens after between 0 and size-1 instants
   * */
  def release[A](dsg1 : Gen[PStream[A]], dsg2 : Gen[PStream[A]]) : Gen[PStream[A]] =
    Gen.sized { size =>
      if (size <= 0)
        Gen.const(PStream.empty)
      else if (size == 1) for {
        isReleased <- arbitrary[Boolean]
        proof <- if (isReleased) (dsg1 + dsg2) else dsg2
      } yield proof
      else for {
          isReleased <- arbitrary[Boolean]
          ds <- if (!isReleased)
                  always(dsg2, Timeout(size))
                else for {
                  proofOffset <- Gen.choose(0, size-1)
                  prefix <- always(dsg2, Timeout(proofOffset))
                  ending <- laterN(proofOffset, dsg1 + dsg2)
                } yield prefix #+ ending
      } yield ds
    }

  def release[A](dsg1 : Gen[PStream[A]], dsg2 : Gen[PStream[A]], t : Timeout) : Gen[PStream[A]] =
    Gen.resize(t.instants, release(dsg1, dsg2))
}

class PStreamGen[A](self : Gen[PStream[A]]) {
  import PStreamGen._
  import PStreamGenConversions._
  /** Returns the generator that results from concatenating the sequences
   *  generated by the generator wrapped by this, and other
   * */
  def ++(other : Gen[PStream[A]]) : Gen[PStream[A]] = UtilsGen.concSeq(self, other)

  /** @return a generator for the batch-by-batch concatenation of the PDStreams
  * generated by the generator wrapped by this, and other
  * Note we fill either PDStreams with empty batches. This implies PDStreams
  * are implicitly treated as they where infinitely extended with empty batches
  */
  def +(other : Gen[PStream[A]]) : Gen[PStream[A]] = dstreamUnion(self, other)

  def next : Gen[PStream[A]] = PStreamGen.next(self)
  def laterN(n : Int) : Gen[PStream[A]] = PStreamGen.laterN(n, self)
  def eventually : Gen[PStream[A]] = PStreamGen.eventually(self)
  def until(other : Gen[PStream[A]]) : Gen[PStream[A]] = PStreamGen.until(self, other)
  def always : Gen[PStream[A]] = PStreamGen.always(self)
  def release(other : Gen[PStream[A]]) : Gen[PStream[A]] = PStreamGen.release(self, other)
}